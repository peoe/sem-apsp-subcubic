\section{Introduction to APSP}

\begin{frame}{Shortest Paths Problems\footnote{\cite[Section~24]{Cormen2001}}}
    Consider a possibly directed graph $G = (V, E)$ with weights $w \in E'$.
    We say that a path $\tilde{p} = (e_1, e_2, \dots, e_n), e_1 = (a, \cdot), e_n = (\cdot, b)$ is a \emph{shortest path} from a vertex $a$ to a vertex $b$, iff
    \[
        \tilde{p} = \argmin\limits_{p\text{ path from }a\text{ to }b} w(p),
    \]
    where $\begin{aligned}[t]w(p) = \sum\limits_{i = 1}^n w(e_i)\end{aligned}$.
\end{frame}

\begin{frame}{Shortest Paths Problems}
    \begin{alertblock}{Variants}
        \begin{itemize}
            \item<1-> Single Pair Shortest Paths Problems (Fix both origin and target vertices $a$ and $b$)
            \item<2-> Single Destination Shortest Paths Problems (Fix target vertex $b$)
            \item<3-> Single Source Shortest Paths Problems (Fix origin vertex $a$)
            \item<4-> All Pairs Shortest Paths Problems
        \end{itemize}
    \end{alertblock}
\end{frame}

\begin{frame}{Single Source Shortest Paths (SSSP)}
    \begin{columns}
        \begin{column}{0.8\textwidth}
            \begin{figure}
                \begin{tikzpicture}[scale=0.6, auto, swap]
                    \foreach \pos / \name in {%
                        {(8, 9)/a}, {(14, 9)/b},%
                        {(-1, 6)/c}, {(5, 6)/d}, {(11, 6)/e},%
                        {(8, 3)/f}, {(14, 3)/g}, {(2, 3)/i},%
                        {(-1, 0)/h}, {(11, 0)/j}%
                    }%
                        \node[vertex] (\name) at \pos {$\name$};
        
                    \foreach \source / \dest / \weight in {%
                        a/b/2, a/c/1, a/d/10, a/e/3,%
                        b/g/1,%
                        c/h/2, c/i/3,%
                        d/f/3, d/i/2,%
                        e/f/12, e/g/1,%
                        f/j/2,%
                        h/i/2, h/j/2%
                    }%
                        \path[edge] (\source) -- node[weight] {$\weight$} (\dest);
        
                    \only<2->{
                    \foreach \vertex / \fr in {f/1}%
                        \path<\fr-> node[selected vertex] at (\vertex) {$\vertex$};
                    }
                \end{tikzpicture}
            \end{figure}
        \end{column}
        \begin{column}{0.2\textwidth}
            \only<3>{
            $\implies \begin{pmatrix}7 \\ 9 \\ 6 \\ 3 \\ 10 \\ 0 \\ 10 \\ 4 \\ 5 \\ 2\end{pmatrix}$
            $\begin{matrix}a \\ b \\ c \\ d \\ e \\ f \\ g \\ h \\ i \\ j\end{matrix}$
            }
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}{Solving SSSP}
    \begin{exampleblock}{Assumption}
        We assume that the graph $G$ contains no negative weight cycles.

        Here a \emph{negative weight cycle} refers to a path $p = (e_1, \dots, e_n)$ such that $e_1 = (a, \cdot), e_n = (\cdot, a)$ and $w(p) < 0$.

        If we are looking for a shortest path containing from a vertex $u$ to a vertex $v$, including a negative weight cycle always reduces the weight of the total path.
        Especially, the $\argmin$ in the definition of a shortest path no longer exists, making itself invalid. \Lightning{}
    \end{exampleblock}
\end{frame}

\begin{frame}{Solving SSSP}
    Among others, the \emph{Bellman-Ford} algorithm solves the SSSP problem:

    \begin{algorithm}[H]
        \KwData{Starting vertex $a$}
        Initialize $d(a) = 0, d(v) = \infty \,\forall v \in V \setminus \{ a \}$\;
        \ForEach{$v \in V \setminus \{ a \}$}{
            \ForEach{$e = (u, v) \in E$}{
                \If{$d(v) > d(u) + w(e)$}{
                    $d(v) = d(u) + w(e)$
                }
            }
        }
    \end{algorithm}

    \only<2-3>{
        \begin{exampleblock}{Note}
            It is easy to keep track of each vertex' predecessor to later recover the shortest path to any given vertex.

            \uncover<3>{
                Bellman-Ford can also check for the existence of negative weight cycles.\only<3>{\footnote[1]{\cite[Section~24.1]{Cormen2001}}}
            }
        \end{exampleblock}
    }

    \only<4>{
        Bellman-Ford requires $\mathcal{O}\left( \abs{V} \abs{E} \right)$ time, which trivially amounts to $\mathcal{O}(n^3)$.
    }
\end{frame}

\begin{frame}{All Pairs Shortest Paths (APSP)\only<1>{\footnote[1]{\cite[Section~25.1]{Cormen2001}}}}
    The \emph{All Pairs Shortest Paths} problem can be naively solved by applying Bellman-Ford to every vertex in $G$.
    However faster alternatives are available, such as making use of \emph{repeated squaring}.
    
    \uncover<2->{
        To illustrate:
        \begin{columns}
            \begin{column}{.39\textwidth}
                \begin{align*}
                    L_1 &= W \\
                    L_2 &= W \cdot W = W^2 \\
                    L_3 &= W^2 \cdot W \\
                    &\vdots \\
                    L_n &= W^{n - 1} \cdot W
                \end{align*}
            \end{column}
            \begin{column}{.59\textwidth}
                \only<3->{
                    \begin{align*}
                        L_1 &= W \\
                        L_2 &= W \cdot W \\
                        L_4 &= W^2 \cdot W^2 \\
                        &\vdots \\
                        L_{2^{\lceil \log(n - 1) \rceil}} &= W^{2^{\lceil \log(n - 1) \rceil - 1}} \cdot W^{2^{\lceil \log(n - 1) \rceil - 1}}
                    \end{align*}
                }
            \end{column}
        \end{columns}
    }

    \uncover<4>{
        \begin{exampleblock}{Note}
            The only relevant property of the matrix product $\cdot$ here is the fact that it preserves the quadratic matrix structure!
        \end{exampleblock}
    }
\end{frame}

\begin{frame}{All Pairs Shortest Paths (APSP)}
    \begin{algorithm}[H]
        \KwData{Initialized weight matrix $W$}
        $L_1 = W, m = 1$\;
        \While{$m < n - 1$}{
            Consider $L_{m}$ to have entries $l_{i, j}$\;
            Consider $L_{2 m}$ to be a new $n \times n$ matrix with entries $l'_{i, j}$\;
            \For{$i = 1, \dots, n$}{
                \For{$j = 1, \dots, n$}{
                    $l'_{i, j} = \infty$\;
                    \For{$k = 1, \dots, n$}{
                        $l'_{i, j} = \min \{ l_{i, j}, l_{i, k} + l_{k, j} \}$
                    }
                }
            }
            $m = 2m$\;
        }
    \end{algorithm}

    \uncover<2>{
        This takes a time of $\mathcal{O}\left( n^3 \log(n) \right)$.
    }
\end{frame}
        
\begin{frame}{All Pairs Shortest Paths (APSP)}
    \only<1, 2>{
        Omitting the squared matrix approach and directly calculating the updates on the matrix, we obtain the \emph{Floyd-Warshall} algorithm.
        This only takes $\mathcal{O}\left( n^3 \right)$.
    }

    \uncover<2->{
        \begin{algorithm}[H]
            \KwData{Initialized weight matrix $W$}
            $D_0 = W$ with entries $d_{i, j}$\;
            \For{$k = 1, \dots, n$}{
                Consider $D_{k - 1}$ to have entries $d_{i, j}$\;
                Consider $D_{k}$ to be a new $n \times n$ matrix with entries $d'_{i, j}$\;
                \For{$i = 1, \dots, n$}{
                    \For{$j = 1, \dots, n$}{
                        $d'_{i, j} = \min \{ d_{i, j}, d_{i, k} + d_{k, j} \}$\;
                    }
                }
            }
        \end{algorithm}
    }

    \only<3>{
        \begin{exampleblock}{Note}
            It is relatively easy to keep track of a vertex' predecessor when updating the weights, making it possible to retrieve the shortest path after runtime.
        \end{exampleblock}
    }
\end{frame}
